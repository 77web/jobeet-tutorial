# Jobeet Day 6: More with the Entity

## The Doctrine Query Object

From the second day’s requirements: “On the homepage, the user sees the latest active jobs”.
But as of now, all jobs are displayed, whether they are active or not:
```php
public function listAction() : Response
{
    $jobs = $this->getDoctrine()->getRepository(Job::class)->findAll();

    return $this->render('job/list.html.twig', [
        'jobs' => $jobs,
    ]);
}
```

An active job is one that was posted less than 30 days ago.
The `$jobs = $this->getDoctrine()->getRepository(Job::class)->findAll();` method will make a request to the database to get all the jobs.
We are not specifying any condition which means that all the records are retrieved from the database.

Let’s change it to only select active jobs:
```php
public function listAction(EntityManagerInterface $em) : Response
{
    $query = $em->createQuery(
        'SELECT j FROM App:Job j WHERE j.createdAt > :date'
    )->setParameter('date', new \DateTime('-30 days'));

    return $this->render('job/list.html.twig', [
        'jobs' => $jobs,
    ]);
}
```

## Debugging Doctrine generated SQL

Sometimes, it is of great help to see the SQL generated by Doctrine; for instance, to debug a query that does not work as expected.
In the dev environment, thanks to the symfony web debug toolbar, all the information you need is available within the comfort of your browser 

![Doctrine queries](/files/images/screenshot_7.png)

## More lifecycle callbacks

Even if the above code works, it is far from perfect as it does not take into account some requirements from day 2:
*“A user can come back to re-activate or extend the validity of the job for an extra 30 days…”.*

But as the above code only relies on the createdAt value, and because this column stores the creation date, we cannot satisfy the above requirement.

If you remember the database schema we have described during day 3, we also have defined an `expiresAt` column.
Currently, if this value is not set in fixture file, it remains always empty.
But when a job is created, it can be automatically set to 30 days after the current date.

When you need to do something automatically before a Doctrine object is serialized to the database, you can add a new action to the lifecycle callbacks, like we did earlier for the createdAt column.
Open `src/Entity/Job.php` and modify `prePersist` method:

```php
/**
 * @ORM\PrePersist()
 */
public function prePersist()
{
    $this->createdAt = new \DateTime();
    $this->updatedAt = new \DateTime();

    if (!$this->expiresAt) {
        $this->expiresAt = (clone $this->createdAt)->modify('+30 days');
    }
}
```

Now, let’s change the action to use the `expiresAt` column instead of the `createdAt` one to select the active jobs:

```php
public function listAction(EntityManagerInterface $em) : Response
{
    $query = $em->createQuery(
        'SELECT j FROM App:Job j WHERE j.expiresAt > :date'
    )->setParameter('date', new \DateTime());
    $jobs = $query->getResult();

    return $this->render('job/list.html.twig', [
        'jobs' => $jobs,
    ]);
}
```

## More with Fixtures

Refreshing the Jobeet homepage in your browser won’t change anything as the jobs in the database have been posted just a few days ago.
Let’s change the fixtures to add a job that is already expired (`src/DataFixtures/JobFixtures.php`):

```php
$jobExpired = new Job();
$jobExpired->setCategory($manager->merge($this->getReference('category-programming')));
$jobExpired->setType('full-time');
$jobExpired->setCompany('Sensio Labs');
$jobExpired->setLogo('sensio-labs.gif');
$jobExpired->setUrl('http://www.sensiolabs.com/');
$jobExpired->setPosition('Web Developer Expired');
$jobExpired->setLocation('Paris, France');
$jobExpired->setDescription('Lorem ipsum dolor sit amet, consectetur adipisicing elit.');
$jobExpired->setHowToApply('Send your resume to lorem.ipsum [at] dolor.sit');
$jobExpired->setPublic(true);
$jobExpired->setActivated(true);
$jobExpired->setToken('job_expired');
$jobExpired->setEmail('job@example.com');
$jobExpired->setExpiresAt(new \DateTime('-10 days'));

// ...

$manager->persist($jobExpired);
```

Reload the fixtures and refresh your browser to ensure that the old job does not show up:

```bash
bin/console doctrine:fixtures:load
```

## Refactoring

Although the code we have written works fine, it’s not quite right yet. Can you spot the problem?

The Doctrine query code does not belong to the action (the Controller layer), it belongs to the Model layer.
In the MVC model, the Model defines all the business logic, and the Controller only calls the Model to retrieve data from it.
As the code returns a collection of jobs, let’s move the code to the repository, that is part of model layer.
For that we will need to create a custom `repository` class for Job entity and to add the query to that class.

Open `src/Entity/Job.php` and modify `@ORM\Entity` annotation to specify the repository class for this entity:

```php
/**
 * @ORM\Entity(repositoryClass="App\Repository\JobRepository")
 * @ORM\Table(name="jobs")
 * @ORM\HasLifecycleCallbacks()
 */
class Job
```

Now let's create file `JobRepository.php` in `src/Repository` folder:
```php
namespace App\Repository;

use Doctrine\ORM\EntityRepository;

class JobRepository extends EntityRepository
{

}
```

Next, add a new method, `getActiveJobs()`, to the newly created repository class.
This method will query for all of the active Job entities sorted by the expiresAt column (and filtered by category if it receives the $categoryId parameter).

```php
// ...
use App\Entity\Job;

class JobRepository extends EntityRepository
{
    /**
     * @param int|null $categoryId
     *
     * @return Job[]
     */
    public function getActiveJobs(int $categoryId = null)
    {
        $qb = $this->createQueryBuilder('j')
            ->where('j.expiresAt > :date')
            ->setParameter('date', new \DateTime())
            ->orderBy('j.expiresAt', 'DESC');

        if ($categoryId) {
            $qb->andWhere('j.category = :categoryId')
                ->setParameter('categoryId', $categoryId);
        }

        return $qb->getQuery()->getResult();
    }
}
```

Now the action code can use this new method to retrieve the active jobs:

```php
public function listAction(EntityManagerInterface $em) : Response
{
    $jobs = $em->getRepository(Job::class)->getActiveJobs();

    return $this->render('job/list.html.twig', [
        'jobs' => $jobs,
    ]);
}
```

This refactoring has several benefits over the previous code:

- The logic to get the active jobs is now in the Repository, where it belongs
- The code in the controller is thinner and much more readable
- The `getActiveJobs()` method is re-usable (for instance in another action)

## Additional information

## Next Steps

Continue this tutorial here: [Jobeet Day 7: Playing with the Category Page](/days/day-7.md)

Previous post is available here: [Jobeet Day 5: The Routing](/days/day-5.md)

Main page is available here: [Symfony 4.0 Jobeet Tutorial](/README.md)
